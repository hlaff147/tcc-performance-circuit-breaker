# Análise de Desempenho e Resiliência em Microsserviços Síncronos: Um Estudo Experimental do Padrão Circuit Breaker

## 1. Contextualização (A Era dos Microsserviços)
A adoção de arquiteturas de microsserviços tornou-se onipresente em organizações que precisam construir plataformas digitais de grande escala, disponibilidade contínua e ciclos de evolução acelerados. Ecossistemas de comércio eletrônico e, em especial, sistemas de processamento de pagamentos, são exemplos emblemáticos desse movimento, pois demandam flexibilidade para incorporar novos meios de pagamento, tolerância a falhas e capacidade de adaptação rápida a volumes variáveis de transações. O particionamento de funcionalidades em serviços independentes facilita o desenvolvimento paralelo, a escalabilidade seletiva e a implantação contínua. Contudo, essa independência lógica é sustentada por interações em tempo real entre serviços, frequentemente estabelecidas por APIs REST e clientes declarativos como o Spring Cloud OpenFeign. A comunicação síncrona simplifica a implementação e a observabilidade, mas introduz um forte acoplamento temporal: o serviço consumidor permanece bloqueado até que a resposta do serviço dependente seja recebida ou um timeout seja atingido. Esse padrão, quando aplicado a cadeias críticas como autorizações financeiras, amplifica a fragilidade do sistema diante de latências elevadas ou indisponibilidade intermitente na infraestrutura externa.

## 2. Definição do Problema (O Risco no Sistema de Pagamento)
Este Trabalho de Conclusão de Curso foca no domínio de pagamentos on-line, no qual um `servico-pagamento` orquestra as etapas da jornada do cliente para autorizar compras. Essa aplicação central depende, de forma síncrona, de um `servico-adquirente` responsável por encaminhar a transação a um gateway externo (por exemplo, Cielo ou Rede) e retornar a decisão de autorização. O cenário de risco emerge quando essa dependência apresenta degradação operacional. Caso o `servico-adquirente` experimente alta latência, o `servico-pagamento` aguardará a resposta até o limite definido pelo timeout, mantendo uma thread dedicada durante todo esse período. Quando o volume de requisições simultâneas cresce, a fila de chamadas bloqueadas consome rapidamente o pool de threads do `servico-pagamento`, culminando em **thread pool starvation**. A consequência é severa: o serviço principal deixa de aceitar novas requisições, provocando uma **falha em cascata** que interrompe o checkout e compromete a experiência do usuário. Se o `servico-adquirente` falhar completamente (por exemplo, retornando HTTP 500), o efeito é ainda mais dramático, pois cada tentativa resulta em timeout ou exceções propagadas, derrubando a aplicação em poucos segundos.

## 3. A Solução Proposta (Padrões de Resiliência e o Circuit Breaker)
Padrões de resiliência, tradicionalmente agrupados sob o guarda-chuva de *fault tolerance*, surgem como contramedidas a essa fragilidade. Entre eles, o padrão Circuit Breaker (CB) destaca-se como um mecanismo sofisticado para conter falhas em cascata. O CB monitora as chamadas ao serviço dependente e opera segundo uma máquina de estados composta por três modos: **Fechado**, **Aberto** e **Semiaberto**. No estado Fechado, o serviço consumidor executa chamadas normalmente e o CB coleta métricas de sucesso e falha. Ao detectar uma taxa de falhas ou tempo de resposta acima de limites configurados, o circuito é **Aberto**, interrompendo novas tentativas de chamadas e falhando rapidamente (*fail-fast*). Esse comportamento protege o serviço consumidor da exaustão de recursos e evita contribuir para a sobrecarga do serviço dependente. Após um período de resfriamento, o CB entra no estado **Semiaberto**, permitindo um número controlado de chamadas de teste. Se elas forem bem-sucedidas, o circuito retorna ao estado Fechado; caso contrário, reabre. Além disso, é comum empregar mecanismos de *fallback* para entregar respostas degradadas, mas ainda úteis, enquanto o serviço dependente se recupera. Dessa forma, o Circuit Breaker harmoniza a necessidade de disponibilidade do consumidor com a estabilidade do ecossistema.

## 4. A Lacuna e a Justificativa (A Conexão com o Artigo)
A literatura recente reforça a relevância de compreender o comportamento de Circuit Breakers em arquiteturas de microsserviços críticos. O artigo "Performance Modeling of Microservices with Circuit Breakers using Stochastic Petri Nets" (Pinheiro, Dantas, et al., 2024) propõe uma modelagem analítica baseada em Redes de Petri Estocásticas (SPNs) para prever a performance de sistemas que utilizam o padrão CB. Esse trabalho demonstra que a parametrização cuidadosa do Circuit Breaker permite cumprir Acordos de Nível de Serviço (SLAs) mesmo diante de dependências instáveis, ao simular o impacto de diferentes políticas de timeout, limiares de falha e períodos de resfriamento. A pesquisa de Pinheiro e colaboradores, entretanto, permanece no âmbito teórico-exploratório: ela estima o comportamento esperado antes da implantação em produção. Este TCC estabelece a ponte experimental necessária entre teoria e prática. Em vez de apenas modelar, propõe-se **implementar** um ecossistema realista em Java/Spring Boot, instrumentado com Resilience4j, e **executar** campanhas de benchmark com Docker e k6 para **medir** empiricamente vazão, latência (p99) e taxa de erro sob cenários controlados de operação normal, alta latência e falha total. A validação empírica complementa a modelagem ao fornecer evidências quantitativas observadas em execução real, fortalecendo a compreensão sobre os trade-offs de desempenho do Circuit Breaker e subsidiando decisões de engenharia em contextos de missão crítica.

## 5. Objetivos
**Objetivo Geral.** Avaliar quantitativamente o impacto do padrão Circuit Breaker no desempenho e na resiliência de um microsserviço de pagamento síncrono.

**Objetivos Específicos.**
1. Implementar um ecossistema de microsserviços composto por `servico-pagamento` e `servico-adquirente`, utilizando Spring Boot, Spring Cloud OpenFeign e orquestração via Docker.
2. Desenvolver duas versões do `servico-pagamento`: (V1) Baseline com timeouts básicos e (V2) aprimorada com Resilience4j, Circuit Breaker e mecanismos de fallback.
3. Construir e executar um benchmark automatizado com k6, inspirado nos scripts de referência, para simular cenários de operação normal, latência elevada e falha total.
4. Analisar comparativamente as métricas de vazão, latência p99 e taxa de erro obtidas nas execuções, destacando os benefícios e custos da adoção do Circuit Breaker.

## 6. Estrutura do Documento
O restante desta monografia está organizado da seguinte forma. O Capítulo 2 apresenta a fundamentação teórica, detalhando conceitos de microsserviços, padrões de resiliência e trabalhos correlatos, incluindo a modelagem com SPNs. O Capítulo 3 descreve a metodologia experimental, abrangendo a arquitetura dos microsserviços, a configuração dos ambientes Docker e o desenho dos testes com k6. O Capítulo 4 discute os resultados obtidos a partir das execuções do benchmark, comparando as versões Baseline e Circuit Breaker. Por fim, o Capítulo 5 reúne as conclusões, sintetizando as principais contribuições, limitações do estudo e oportunidades de trabalhos futuros.
